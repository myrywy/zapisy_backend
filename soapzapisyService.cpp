/* soapzapisyService.cpp
   Generated by gSOAP 2.8.30 for zapisy.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "soapzapisyService.h"

zapisyService::zapisyService()
{	this->soap = soap_new();
	this->soap_own = true;
	zapisyService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

zapisyService::zapisyService(const zapisyService& rhs)
{	this->soap = rhs.soap;
	this->soap_own = false;
}

zapisyService::zapisyService(struct soap *_soap)
{	this->soap = _soap;
	this->soap_own = false;
	zapisyService_init(_soap->imode, _soap->omode);
}

zapisyService::zapisyService(soap_mode iomode)
{	this->soap = soap_new();
	this->soap_own = true;
	zapisyService_init(iomode, iomode);
}

zapisyService::zapisyService(soap_mode imode, soap_mode omode)
{	this->soap = soap_new();
	this->soap_own = true;
	zapisyService_init(imode, omode);
}

zapisyService::~zapisyService()
{	if (this->soap_own)
		soap_free(this->soap);
}

void zapisyService::zapisyService_init(soap_mode imode, soap_mode omode)
{	soap_imode(this->soap, imode);
	soap_omode(this->soap, omode);
	static const struct Namespace namespaces[] = {
        {"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
        {"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
        {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
        {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
        {"z1", "localhost/zapisy.wsdl", NULL, NULL},
        {NULL, NULL, NULL, NULL}
    };
	soap_set_namespaces(this->soap, namespaces);
}

void zapisyService::destroy()
{	soap_destroy(this->soap);
	soap_end(this->soap);
}

void zapisyService::reset()
{	this->destroy();
	soap_done(this->soap);
	soap_initialize(this->soap);
	zapisyService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

#ifndef WITH_PURE_VIRTUAL
zapisyService *zapisyService::copy()
{	zapisyService *dup = SOAP_NEW_COPY(zapisyService);
	if (dup)
		soap_copy_context(dup->soap, this->soap);
	return dup;
}
#endif

zapisyService& zapisyService::operator=(const zapisyService& rhs)
{	if (this->soap_own)
		soap_free(this->soap);
	this->soap = rhs.soap;
	this->soap_own = false;
	return *this;
}

int zapisyService::soap_close_socket()
{	return soap_closesock(this->soap);
}

int zapisyService::soap_force_close_socket()
{	return soap_force_closesock(this->soap);
}

int zapisyService::soap_senderfault(const char *string, const char *detailXML)
{	return ::soap_sender_fault(this->soap, string, detailXML);
}

int zapisyService::soap_senderfault(const char *subcodeQName, const char *string, const char *detailXML)
{	return ::soap_sender_fault_subcode(this->soap, subcodeQName, string, detailXML);
}

int zapisyService::soap_receiverfault(const char *string, const char *detailXML)
{	return ::soap_receiver_fault(this->soap, string, detailXML);
}

int zapisyService::soap_receiverfault(const char *subcodeQName, const char *string, const char *detailXML)
{	return ::soap_receiver_fault_subcode(this->soap, subcodeQName, string, detailXML);
}

void zapisyService::soap_print_fault(FILE *fd)
{	::soap_print_fault(this->soap, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void zapisyService::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this->soap, os);
}
#endif

char *zapisyService::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this->soap, buf, len);
}
#endif

void zapisyService::soap_noheader()
{	this->soap->header = NULL;
}

::SOAP_ENV__Header *zapisyService::soap_header()
{	return this->soap->header;
}

int zapisyService::run(int port)
{	if (!soap_valid_socket(this->soap->master) && !soap_valid_socket(this->bind(NULL, port, 100)))
		return this->soap->error;
	for (;;)
	{	if (!soap_valid_socket(this->accept()))
		{	if (this->soap->errnum == 0) // timeout?
				this->soap->error = SOAP_OK;
			break;
		}
		if (this->serve())
			break;
		this->destroy();
	}
	return this->soap->error;
}

#if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
int zapisyService::ssl_run(int port)
{	if (!soap_valid_socket(this->soap->master) && !soap_valid_socket(this->bind(NULL, port, 100)))
		return this->soap->error;
	for (;;)
	{	if (!soap_valid_socket(this->accept()))
		{	if (this->soap->errnum == 0) // timeout?
				this->soap->error = SOAP_OK;
			break;
		}
		if (this->ssl_accept() || this->serve())
			break;
		this->destroy();
	}
	return this->soap->error;
}
#endif

SOAP_SOCKET zapisyService::bind(const char *host, int port, int backlog)
{	return soap_bind(this->soap, host, port, backlog);
}

SOAP_SOCKET zapisyService::accept()
{	return soap_accept(this->soap);
}

#if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
int zapisyService::ssl_accept()
{	return soap_ssl_accept(this->soap);
}
#endif

int zapisyService::serve()
{
#ifndef WITH_FASTCGI
	unsigned int k = this->soap->max_keep_alive;
#endif
	do
	{

#ifndef WITH_FASTCGI
		if (this->soap->max_keep_alive > 0 && !--k)
			this->soap->keep_alive = 0;
#endif

		if (soap_begin_serve(this->soap))
		{	if (this->soap->error >= SOAP_STOP)
				continue;
			return this->soap->error;
		}
		if (dispatch() || (this->soap->fserveloop && this->soap->fserveloop(this->soap)))
		{
#ifdef WITH_FASTCGI
			soap_send_fault(this->soap);
#else
			return soap_send_fault(this->soap);
#endif
		}

#ifdef WITH_FASTCGI
		soap_destroy(this->soap);
		soap_end(this->soap);
	} while (1);
#else
	} while (this->soap->keep_alive);
#endif
	return SOAP_OK;
}

static int serve_z1__zapiszProjekt(struct soap*, zapisyService*);
static int serve_z1__dodajProjekt(struct soap*, zapisyService*);
static int serve_z1__zapiszTermin(struct soap*, zapisyService*);
static int serve_z1__dodajTermin(struct soap*, zapisyService*);
static int serve_z1__eksportujProjekt(struct soap*, zapisyService*);
static int serve_z1__eksportujTermin(struct soap*, zapisyService*);
static int serve_z1__eksportujPrzedmiot(struct soap*, zapisyService*);

int zapisyService::dispatch()
{	return dispatch(this->soap);
}

int zapisyService::dispatch(struct soap* soap)
{
	zapisyService_init(soap->imode, soap->omode);

	soap_peek_element(soap);
	if (!soap_match_tag(soap, soap->tag, "z1:zapiszProjekt"))
		return serve_z1__zapiszProjekt(soap, this);
	if (!soap_match_tag(soap, soap->tag, "z1:dodajProjekt"))
		return serve_z1__dodajProjekt(soap, this);
	if (!soap_match_tag(soap, soap->tag, "z1:zapiszTermin"))
		return serve_z1__zapiszTermin(soap, this);
	if (!soap_match_tag(soap, soap->tag, "z1:dodajTermin"))
		return serve_z1__dodajTermin(soap, this);
	if (!soap_match_tag(soap, soap->tag, "z1:eksportujProjekt"))
		return serve_z1__eksportujProjekt(soap, this);
	if (!soap_match_tag(soap, soap->tag, "z1:eksportujTermin"))
		return serve_z1__eksportujTermin(soap, this);
	if (!soap_match_tag(soap, soap->tag, "z1:eksportujPrzedmiot"))
		return serve_z1__eksportujPrzedmiot(soap, this);
	return soap->error = SOAP_NO_METHOD;
}

static int serve_z1__zapiszProjekt(struct soap *soap, zapisyService *service)
{	struct z1__zapiszProjekt soap_tmp_z1__zapiszProjekt;
	struct z1__zapiszProjektResponse _param_1;
	soap_default_z1__zapiszProjektResponse(soap, &_param_1);
	soap_default_z1__zapiszProjekt(soap, &soap_tmp_z1__zapiszProjekt);
	if (!soap_get_z1__zapiszProjekt(soap, &soap_tmp_z1__zapiszProjekt, "z1:zapiszProjekt", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->zapiszProjekt(soap_tmp_z1__zapiszProjekt.ID, soap_tmp_z1__zapiszProjekt.zapisywany, _param_1);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__zapiszProjektResponse(soap, &_param_1);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__zapiszProjektResponse(soap, &_param_1, "z1:zapiszProjektResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__zapiszProjektResponse(soap, &_param_1, "z1:zapiszProjektResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_z1__dodajProjekt(struct soap *soap, zapisyService *service)
{	struct z1__dodajProjekt soap_tmp_z1__dodajProjekt;
	struct z1__dodajProjektResponse _param_2;
	soap_default_z1__dodajProjektResponse(soap, &_param_2);
	soap_default_z1__dodajProjekt(soap, &soap_tmp_z1__dodajProjekt);
	if (!soap_get_z1__dodajProjekt(soap, &soap_tmp_z1__dodajProjekt, "z1:dodajProjekt", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->dodajProjekt(soap_tmp_z1__dodajProjekt.projekt, _param_2);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__dodajProjektResponse(soap, &_param_2);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__dodajProjektResponse(soap, &_param_2, "z1:dodajProjektResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__dodajProjektResponse(soap, &_param_2, "z1:dodajProjektResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_z1__zapiszTermin(struct soap *soap, zapisyService *service)
{	struct z1__zapiszTermin soap_tmp_z1__zapiszTermin;
	struct z1__zapiszTerminResponse _param_3;
	soap_default_z1__zapiszTerminResponse(soap, &_param_3);
	soap_default_z1__zapiszTermin(soap, &soap_tmp_z1__zapiszTermin);
	if (!soap_get_z1__zapiszTermin(soap, &soap_tmp_z1__zapiszTermin, "z1:zapiszTermin", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->zapiszTermin(soap_tmp_z1__zapiszTermin.ID, soap_tmp_z1__zapiszTermin.zapisywany, _param_3);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__zapiszTerminResponse(soap, &_param_3);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__zapiszTerminResponse(soap, &_param_3, "z1:zapiszTerminResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__zapiszTerminResponse(soap, &_param_3, "z1:zapiszTerminResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_z1__dodajTermin(struct soap *soap, zapisyService *service)
{	struct z1__dodajTermin soap_tmp_z1__dodajTermin;
	struct z1__dodajTerminResponse _param_4;
	soap_default_z1__dodajTerminResponse(soap, &_param_4);
	soap_default_z1__dodajTermin(soap, &soap_tmp_z1__dodajTermin);
	if (!soap_get_z1__dodajTermin(soap, &soap_tmp_z1__dodajTermin, "z1:dodajTermin", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->dodajTermin(soap_tmp_z1__dodajTermin.termin, _param_4);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__dodajTerminResponse(soap, &_param_4);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__dodajTerminResponse(soap, &_param_4, "z1:dodajTerminResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__dodajTerminResponse(soap, &_param_4, "z1:dodajTerminResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_z1__eksportujProjekt(struct soap *soap, zapisyService *service)
{	struct z1__eksportujProjekt soap_tmp_z1__eksportujProjekt;
	struct z1__eksportujProjektResponse _param_5;
	soap_default_z1__eksportujProjektResponse(soap, &_param_5);
	soap_default_z1__eksportujProjekt(soap, &soap_tmp_z1__eksportujProjekt);
	if (!soap_get_z1__eksportujProjekt(soap, &soap_tmp_z1__eksportujProjekt, "z1:eksportujProjekt", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->eksportujProjekt(soap_tmp_z1__eksportujProjekt.ID, _param_5);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__eksportujProjektResponse(soap, &_param_5);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__eksportujProjektResponse(soap, &_param_5, "z1:eksportujProjektResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__eksportujProjektResponse(soap, &_param_5, "z1:eksportujProjektResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_z1__eksportujTermin(struct soap *soap, zapisyService *service)
{	struct z1__eksportujTermin soap_tmp_z1__eksportujTermin;
	struct z1__eksportujTerminResponse _param_6;
	soap_default_z1__eksportujTerminResponse(soap, &_param_6);
	soap_default_z1__eksportujTermin(soap, &soap_tmp_z1__eksportujTermin);
	if (!soap_get_z1__eksportujTermin(soap, &soap_tmp_z1__eksportujTermin, "z1:eksportujTermin", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->eksportujTermin(soap_tmp_z1__eksportujTermin.ID, _param_6);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__eksportujTerminResponse(soap, &_param_6);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__eksportujTerminResponse(soap, &_param_6, "z1:eksportujTerminResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__eksportujTerminResponse(soap, &_param_6, "z1:eksportujTerminResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}

static int serve_z1__eksportujPrzedmiot(struct soap *soap, zapisyService *service)
{	struct z1__eksportujPrzedmiot soap_tmp_z1__eksportujPrzedmiot;
	struct z1__eksportujPrzedmiotResponse _param_7;
	soap_default_z1__eksportujPrzedmiotResponse(soap, &_param_7);
	soap_default_z1__eksportujPrzedmiot(soap, &soap_tmp_z1__eksportujPrzedmiot);
	if (!soap_get_z1__eksportujPrzedmiot(soap, &soap_tmp_z1__eksportujPrzedmiot, "z1:eksportujPrzedmiot", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = service->eksportujPrzedmiot(soap_tmp_z1__eksportujPrzedmiot.ID, _param_7);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_z1__eksportujPrzedmiotResponse(soap, &_param_7);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_z1__eksportujPrzedmiotResponse(soap, &_param_7, "z1:eksportujPrzedmiotResponse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_z1__eksportujPrzedmiotResponse(soap, &_param_7, "z1:eksportujPrzedmiotResponse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}
/* End of server object code */
